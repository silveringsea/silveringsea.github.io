
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>java8 | silveringsea on the run</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="silveringsea">
    

    
    <meta name="description" content="Optional　　Java 8中的Optional是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。
　　java中非常讨厌的一点就是nullpoint，碰到空指针就会出错抛Exception，然后需要逐行检查是哪个对象为空，带来大量的不必要精力损耗，抛出NPE错误不是用户操作的错误，而是开发人员的错误，应该被避免，那么只能在每个方法中加">
<meta property="og:type" content="article">
<meta property="og:title" content="java8">
<meta property="og:url" content="http://silveringsea.github.io/2015/07/05/java8/index.html">
<meta property="og:site_name" content="silveringsea on the run">
<meta property="og:description" content="Optional　　Java 8中的Optional是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。
　　java中非常讨厌的一点就是nullpoint，碰到空指针就会出错抛Exception，然后需要逐行检查是哪个对象为空，带来大量的不必要精力损耗，抛出NPE错误不是用户操作的错误，而是开发人员的错误，应该被避免，那么只能在每个方法中加">
<meta property="og:updated_time" content="2016-02-22T15:11:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java8">
<meta name="twitter:description" content="Optional　　Java 8中的Optional是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。
　　java中非常讨厌的一点就是nullpoint，碰到空指针就会出错抛Exception，然后需要逐行检查是哪个对象为空，带来大量的不必要精力损耗，抛出NPE错误不是用户操作的错误，而是开发人员的错误，应该被避免，那么只能在每个方法中加">

    
    <link rel="alternative" href="/atom.xml" title="silveringsea on the run" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="silveringsea on the run" title="silveringsea on the run"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="silveringsea on the run">silveringsea on the run</a></h1>
				<h2 class="blog-motto">going forward</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页 | Home</a></li>
					
						<li><a href="/archives">归档 | Archives</a></li>
					
						<li><a href="/about">简介 | About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:silveringsea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/05/java8/" title="java8" itemprop="url">java8</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-07-05T01:29:30.000Z" itemprop="datePublished"> 发表于 2015-07-05</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional"><span class="toc-number">1.</span> <span class="toc-text">Optional</span></a></li></ol>
		
		</div>
		
		<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>　　Java 8中的Optional<t>是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。</t></p>
<p>　　java中非常讨厌的一点就是nullpoint，碰到空指针就会出错抛Exception，然后需要逐行检查是哪个对象为空，带来大量的不必要精力损耗，抛出NPE错误不是用户操作的错误，而是开发人员的错误，应该被避免，那么只能在每个方法中加入非空检查，阅读性和维护性都比较差。</p>
<p>　　如下面这个代码的手工非空检查：<br>public void addAddressToCustomer(Customer customer, Address newAddress){<br> if ( customer == null || newAddress == null)<br> return;</p>
<p> if ( customer.getAddresses() == null ){<br>   customer.setAddresses ( new ArrayList&lt;&gt;());<br> }<br> customer.addAddress(newAddress);<br>}</p>
<p>　　另外还有一些开发人员喜欢通过非空检查来实现业务逻辑，空对象不应该用来决定系统的行为，它们是意外的Exceptional值，应当被看成是错误，而不是业务逻辑状态。</p>
<p>　　当我们一个方法返回List集合时，应该总是返回一个空的List，而不是Null，这就允许调用者能够遍历它而不必检查Null，否则就抛出NPE。</p>
<p>　　但是如果我们根据标识键ID查询数据库，没有查到，需要返回一个空对象怎么办？有人建议抛出Exception，其实这不符合函数方法一进一出的原则，变成一个函数方法有两个返回，一个是正常返回，一个出错Exception，函数式编程范式告诫我们不要轻易抛Exception。</p>
<p>　　这时Java 8的Optional就发挥作用了，允许我们返回一个空的对象。</p>
<p>　　Optional<t>有方法 isPresent() 和 get() 是用来检查其包含的对象是否为空或不是，然后返回它，如：</t></p>
<p>Optional<sometype> someValue = someMethod();</sometype></p>
<p>if (someValue.isPresent()) { // check</p>
<pre><code>someValue.get().someOtherMethod(); // retrieve and call
</code></pre><p>}</p>
<p>　　但是这种用法并不能体现Java 8的全部好处，你可以将Optional看成是需要使用某个T值的方法之间某种中间人或者协调者Mediator，而不只是一个普通对象的包装器。</p>
<p>　　如果你有一个值返回类型T，你有一个方法需要使用这个值，那么你可以让 Optional<t> 处于中间，确保它们之间交互进行，而不必要人工干预。</t></p>
<p>　　这样，协调者Optional<t>能够照顾T的值提供给你的方法作为输入参数，在这种情况下，如果T是空，可以确保不会出错，这样在T值为空时也可以让一切都正常运作，你也可以让Optional<t>执行其他动作，如执行一段代码块等等，这样它就实际上是语言机制的很好的补充。</t></t></p>
<p>　　下面这个案例涉及到Lambda表达式 方法引用，是将单词流中第一个以”L”开始单词取出，作为返回结果是一个Optional<string>。<br>使用ifPresent()</string></p>
<p>　　这个案例的代码如下：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;L&quot;))

.findFirst();
</code></pre><p>longest.ifPresent(name -&gt; {</p>
<pre><code>    String s = name.toUpperCase();

    System.out.println(&quot;The longest name is &quot;+ s);

});
</code></pre><p>　　这里ifPresent() 是将一个Lambda表达式作为输入，T值如果不为空将传入这个lambda。那么这个lambda将不为空的单词转为大写输出显示。在前面names单词流寻找结果中，有可能找不到开始字母为L的单词，返回为空，也可能找到不为空，这两种情况都传入lambda中，无需我们打开盒子自己编写代码来判断，它自动帮助我们完成了，无需人工干预。</p>
<p>使用map()</p>
<p>　　如果你想从Optional<t>中返回一个值怎么办？使用 map()，如下：</t></p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;L&quot;))

.findFirst();
</code></pre><p>Optional<string> lNameInCaps = longest.map(String::toUpperCase);</string></p>
<p>　　使用Optional<t>的map方法能够返回另外一个Optional，如上面的 LnameInCaps，因为传入map()的参数值也许会导致一个空值。</t></p>
<p>使用orElse()</p>
<p>　　如果在T可能空时你需要一个值的话，那么可以使用 orElse()，它能在T值存在的情况下返回这个值，否则返回输入值。</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p> String alternate = longest.orElse(“Nimrod”);</p>
<p> System.out.println(alternate); //prints out “Nimrod”</p>
<p>使用orElseGet()</p>
<p>　　orElseGet() 方法类似于orElse()，但是不是直接返回输入参数，而是调用输入参数，返回调用的结果，这个输入参数通常是lambda：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p> String alternate = longest.orElseGet(() -&gt; {</p>
<pre><code>// perform some interesting code operation

// then return the alternate value.

return &quot;Nimrod&quot;;
</code></pre><p> });</p>
<p> System.out.println(alternate);</p>
<p>使用 orElseThrow()</p>
<p>　　orElseThrow()是在当遭遇Null时，决定抛出哪个Exception时使用：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p> Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p>longest.orElseThrow(NoSuchElementStartingWithQException::new);</p>
<p>总结，你能创建下面三种类型的Optional<t>：</t></p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>// 返回一个空的Optional类型;</p>
<p>return Optional.empty();</p>
<p>}</p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>SomeType value = …;</p>
<p>// 使用这个方法，值不可以为空，否则抛exception</p>
<p>return Optional.of(value);</p>
<p>}</p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>SomeType value = …;</p>
<p>// 使用这个方法，值可以为空，如果为空返回Optional.empty</p>
<p>return Optional.ofNullable(value);</p>
<p>// usage</p>
<p>Optional<sometype> someType = getSomeValue();</sometype></p>
<p>首先创建一个函数接口ResultSetProcessor ：</p>
<p>@FunctionalInterface<br>public interface ResultSetProcessor {</p>
<pre><code>public void process(ResultSet resultSet,
                    long currentRow)
                    throws SQLException;
</code></pre><p>}</p>
<p>下面做个简单查询案例，使用这个接口遍历</p>
<p>public static void select(Connection connection,<br>                          String sql,<br>                          ResultSetProcessor processor,<br>                          Object… params) {<br>        try (PreparedStatement ps = connection.prepareStatement(sql)) {<br>            int cnt = 0;<br>            for (Object param : params) {<br>                ps.setObject(++cnt, param));<br>            }<br>            try (ResultSet rs = ps.executeQuery()) {<br>                long rowCnt = 0;<br>                while (rs.next()) {<br>                    processor.process(rs, rowCnt++);<br>                }<br>            } catch (SQLException e) {<br>                throw new DataAccessException(e);<br>            }<br>        } catch (SQLException e) {<br>            throw new DataAccessException(e);<br>        }<br>}</p>
<p>调用这个select语句如下：</p>
<p>select(connection, “select * from MY_TABLE”,(rs, cnt)-&gt; {<br>   System.out.println(rs.getInt(1)+” “+cnt)<br>});</p>
<p>select的第三个参数ResultSetProcessor这是个函数，所以我们传入的是一个匿名函数。<br> Streams API</p>
<p>　　　java 8提供了更强大的 Streams API,我们可以对ResultSet处理更加强大。创建一个自己的Tuple 类型，代表ResultSet中一行记录。</p>
<p>　　　下面我们将一个查询和ResultSet包装在一个Iterator中：</p>
<p>public class ResultSetIterator implements Iterator {</p>
<pre><code>private ResultSet rs;
private PreparedStatement ps;
private Connection connection;
private String sql;

public ResultSetIterator(Connection connection, String sql) {
    assert connection != null;
    assert sql != null;
    this.connection = connection;
    this.sql = sql;
}

public void init() {
    try {
        ps = connection.prepareStatement(sql);
        rs = ps.executeQuery();

    } catch (SQLException e) {
        close();
        throw new DataAccessException(e);
    }
}

@Override
public boolean hasNext() {
    if (ps == null) {
        init();
    }
    try {
        boolean hasMore = rs.next();
        if (!hasMore) {
            close();
        }
        return hasMore;
    } catch (SQLException e) {
        close();
        throw new DataAccessException(e);
    }

}

private void close() {
    try {
        rs.close();
        try {
            ps.close();
        } catch (SQLException e) {
            //nothing we can do here
        }
    } catch (SQLException e) {
        //nothing we can do here
    }
}

@Override
public Tuple next() {
    try {
        return SQL.rowAsTuple(sql, rs);
    } catch (DataAccessException e) {
        close();
        throw e;
    }
}
</code></pre><p>}</p>
<p>这是一个遍历器，每次返回ResultSet的一行记录，返回类型是我们定义Tuple.</p>
<p>关于tuple定义可见源码。</p>
<p>我们和Stream绑定在一起如下：</p>
<p>public static Stream stream(final Connection connection,<br>                                       final String sql,<br>                                       final Object… parms) {<br>  return StreamSupport<br>                .stream(Spliterators.spliteratorUnknownSize(<br>                        new ResultSetIterator(connection, sql), 0), false);<br>}</p>
<p>Java 8 提供StreamSupport静态方法.stream来创建 java.util.stream.Stream实例，同时还需要java.util.stream.Spliterator，这是一个用来遍历和分区一个序列元素(集合)的特殊类型，有了它才能并行处理我们饿操作，而Spliterators 这是能够对已经存在的集合如java.util.Iterator.提供并行操作。</p>
<p>我们调用上面stream如下：</p>
<p>long result = stream(connection, “select TEST_ID from TEST_TABLE”)<br>           .filter((t) -&gt; t.asInt(“TEST_ID”) % 2 == 0)<br>           .limit(100)<br>           .count();</p>
<p>这是查询所有的TEST_ID,然后过滤掉所有非偶数，最后再运行一个计数。非常简单明了。如果你使用ORM/JPA等框架，可能无法让自己的SQL代码如此优雅直接了，它类似Hibernate的 criteria。</p>
<p> <a href="https://github.com/jexenberger/lambda-tuples" target="_blank" rel="external">https://github.com/jexenberger/lambda-tuples</a></p>
<p><a href="http://www.jdon.com/idea/java/java-8-lambda-jdbc.html" target="_blank" rel="external">java8</a></p>
<ol>
<li>实现Runnable线程案例</li>
</ol>
<p>使用() -&gt; {} 替代匿名类：</p>
<p>//Before Java 8:<br>new Thread(new Runnable() {<br>    @Override<br>    public void run() {<br>        System.out.println(“Before Java8 “);<br>    }<br>}).start();</p>
<p>//Java 8 way:<br>new Thread( () -&gt; System.out.println(“In Java8!”) ).start();</p>
<p>Output:<br>too much code, for too little to do<br>Lambda expression rocks !!</p>
<p>你可以使用 下面语法实现Lambda:</p>
<p>(params) -&gt; expression<br>(params) -&gt; statement<br>(params) -&gt; { statements }</p>
<p>如果你的方法并不改变任何方法参数，比如只是输出，那么可以简写如下：<br>() -&gt; System.out.println(“Hello Lambda Expressions”);</p>
<p>如果你的方法接受两个方法参数，如下：</p>
<p>(int even, int odd) -&gt; even + odd</p>
<p>2.实现事件处理</p>
<p>如果你曾经做过Swing 编程，你将永远不会忘记编写事件侦听器代码。使用lambda表达式如下所示写出更好的事件侦听器的代码。</p>
<p>// Before Java 8:<br>JButton show =  new JButton(“Show”);<br>show.addActionListener(new ActionListener() {<br>     @Override<br>     public void actionPerformed(ActionEvent e) {<br>           System.out.println(“without lambda expression is boring”);<br>        }<br>     });</p>
<p>// Java 8 way:<br>show.addActionListener((e) -&gt; {<br>    System.out.println(“Action !! Lambda expressions Rocks”);<br>});</p>
<p>在java 8中你可以使用Lambda表达式替代丑陋的匿名类。</p>
<p>3.使用Lambda表达式遍历List集合</p>
<p>//Prior Java 8 :<br>List features = Arrays.asList(“Lambdas”, “Default Method”,<br>“Stream API”, “Date and Time API”);<br>for (String feature : features) {<br>   System.out.println(feature);<br>}</p>
<p>//In Java 8:<br>List features = Arrays.asList(“Lambdas”, “Default Method”, “Stream API”,<br> “Date and Time API”);<br>features.forEach(n -&gt; System.out.println(n));</p>
<p>// Even better use Method reference feature of Java 8<br>// method reference is denoted by :: (double colon) operator<br>// looks similar to score resolution operator of C++<br>features.forEach(System.out::println);</p>
<p>Output:<br>Lambdas<br>Default Method<br>Stream API<br>Date and Time API</p>
<p>方法引用是使用两个冒号::这个操作符号。<br>4.使用Lambda表达式和函数接口</p>
<p>为了支持函数编程，Java 8加入了一个新的包java.util.function，其中有一个接口java.util.function.Predicate是支持Lambda函数编程：</p>
<p>public static void main(args[]){<br>  List languages = Arrays.asList(“Java”, “Scala”, “C++”, “Haskell”, “Lisp”);</p>
<p>  System.out.println(“Languages which starts with J :”);<br>  filter(languages, (str)-&gt;str.startsWith(“J”));</p>
<p>  System.out.println(“Languages which ends with a “);<br>  filter(languages, (str)-&gt;str.endsWith(“a”));</p>
<p>  System.out.println(“Print all languages :”);<br>  filter(languages, (str)-&gt;true);</p>
<p>   System.out.println(“Print no language : “);<br>   filter(languages, (str)-&gt;false);</p>
<p>   System.out.println(“Print language whose length greater than 4:”);<br>   filter(languages, (str)-&gt;str.length() &gt; 4);<br>}</p>
<p> public static void filter(List names, Predicate condition) {<br>    for(String name: names)  {<br>       if(condition.test(name)) {<br>          System.out.println(name + “ “);<br>       }<br>    }<br>  }<br>}</p>
<p>Output:<br>Languages which starts with J :<br>Java<br>Languages which ends with a<br>Java<br>Scala<br>Print all languages :<br>Java<br>Scala<br>C++<br>Haskell<br>Lisp<br>Print no language :<br>Print language whose length greater than 4:<br>Scala<br>Haskell</p>
<p>//Even better<br> public static void filter(List names, Predicate condition) {<br>    names.stream().filter((name) -&gt; (condition.test(name)))<br>        .forEach((name) -&gt; {System.out.println(name + “ “);<br>    });<br> }</p>
<p>你能看到来自Stream API 的filter方法能够接受 Predicate参数, 能够允许测试多个条件。</p>
<p>5.复杂的结合Predicate 使用</p>
<p>java.util.function.Predicate提供and(), or() 和 xor()可以进行逻辑操作，比如为了得到一串字符串中以”J”开头的4个长度：</p>
<p>// We can even combine Predicate using and(), or() And xor() logical functions<br> // for example to find names, which starts with J and four letters long, you<br> // can pass combination of two Predicate<br> Predicate<string> startsWithJ = (n) -&gt; n.startsWith(“J”);<br> Predicate<string> fourLetterLong = (n) -&gt; n.length() == 4;</string></string></p>
<p> names.stream()<br>      .filter(startsWithJ.and(fourLetterLong))<br>      .forEach((n) -&gt; System.out.print(“\nName, which starts with<br>            ‘J’ and four letter long is : “ + n));</p>
<p>其中startsWithJ.and(fourLetterLong)是使用了AND逻辑操作。</p>
<p>6.使用Lambda实现Map 和 Reduce</p>
<p>最流行的函数编程概念是map，它允许你改变你的对象，在这个案例中，我们将costBeforeTeax集合中每个元素改变了增加一定的数值，我们将Lambda表达式 x -&gt; x*x传送map()方法，这将应用到stream中所有元素。然后我们使用 forEach() 打印出这个集合的元素.</p>
<p>// applying 12% VAT on each purchase<br>// Without lambda expressions:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>for (Integer cost : costBeforeTax) {<br>      double price = cost + .12*cost;<br>      System.out.println(price);<br>}</p>
<p>// With Lambda expression:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>costBeforeTax.stream().map((cost) -&gt; cost + .12*cost)<br>                      .forEach(System.out::println);</p>
<p>Output<br>112.0<br>224.0<br>336.0<br>448.0<br>560.0<br>112.0<br>224.0<br>336.0<br>448.0<br>560.0</p>
<p>reduce() 是将集合中所有值结合进一个，Reduce类似SQL语句中的sum(), avg() 或count(), </p>
<p>// Applying 12% VAT on each purchase<br>// Old way:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>double total = 0;<br>for (Integer cost : costBeforeTax) {<br> double price = cost + .12*cost;<br> total = total + price;</p>
<p>}<br>System.out.println(“Total : “ + total);</p>
<p>// New way:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost)<br>                                    .reduce((sum, cost) -&gt; sum + cost)<br>                                    .get();<br>System.out.println(“Total : “ + bill);</p>
<p>Output<br>Total : 1680.0<br>Total : 1680.0</p>
<p>7.通过filtering 创建一个字符串String的集合</p>
<p>Filtering是对大型Collection操作的一个通用操作，Stream提供filter()方法，接受一个Predicate对象，意味着你能传送lambda表达式作为一个过滤逻辑进入这个方法：</p>
<p>// Create a List with String more than 2 characters<br>List<string> filtered = strList.stream().filter(x -&gt; x.length()&gt; 2)<br>                                        .collect(Collectors.toList());<br>System.out.printf(“Original List : %s, filtered list : %s %n”,<br>                  strList, filtered);</string></p>
<p>Output :<br>Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</p>
<p>8.对集合中每个元素应用函数</p>
<p>我们经常需要对集合中元素运用一定的功能，如表中的每个元素乘以或除以一个值等等.</p>
<p>// Convert String to Uppercase and join them using coma<br>List<string> G7 = Arrays.asList(“USA”, “Japan”, “France”, “Germany”,<br>                                “Italy”, “U.K.”,”Canada”);<br>String G7Countries = G7.stream().map(x -&gt; x.toUpperCase())<br>                                .collect(Collectors.joining(“, “));<br>System.out.println(G7Countries);</string></p>
<p>Output :<br>USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</p>
<p>上面是将字符串转换为大写，然后使用逗号串起来。</p>
<p>9.通过复制不同的值创建一个子列表</p>
<p>使用Stream的distinct()方法过滤集合中重复元素。</p>
<p>// Create List of square of all distinct numbers<br>List<integer> numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);<br>List<integer> distinct = numbers.stream().map( i -&gt; i*i).distinct()<br>                                         .collect(Collectors.toList());<br>System.out.printf(“Original List : %s,  Square Without duplicates :<br>                   %s %n”, numbers, distinct);</integer></integer></p>
<p>Output :<br>Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without<br>                                         duplicates : [81, 100, 9, 16, 49]</p>
<p>10.计算List中的元素的最大值，最小值，总和及平均值</p>
<p>//Get count, min, max, sum, and average for numbers<br>List<integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);<br>IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x)<br>                                            .summaryStatistics();<br>System.out.println(“Highest prime number in List : “ + stats.getMax());<br>System.out.println(“Lowest prime number in List : “ + stats.getMin());<br>System.out.println(“Sum of all prime numbers : “ + stats.getSum());<br>System.out.println(“Average of all prime numbers : “ + stats.getAverage());</integer></p>
<p>Output :<br>Highest prime number in List : 29<br>Lowest prime number in List : 2<br>Sum of all prime numbers : 129<br>Average of all prime numbers : 12.9</p>
<p> 在本教程中主要讲解Java 8新的函数式编程功能，熟悉这些新的 API：streams, 函数接口, map扩展和新的日期API。<br>接口的缺省方法</p>
<p>Java 8让我们能够增加非抽象方法实现到一个接口中， 使用default，这个特点就是 Extension Methods.</p>
<p>interface Formula {</p>
<pre><code>double calculate(int a);
default double sqrt(int a) {
    return Math.sqrt(a);
}
</code></pre><p>}</p>
<p>接口 Formula 定义了一个默认方法sqrt. 该接口实现类只要完成接口中抽象方法calculate即可，而sqrt方法可以被外部使用。</p>
<p>ormula formula = new Formula() {</p>
<pre><code>@Override
public double calculate(int a) {
    return sqrt(a * 100);
}
</code></pre><p>};</p>
<p>formula.calculate(100);     // 100.0<br>formula.sqrt(16);           // 4.0</p>
<p>代码中formula 实现类是一个匿名类，在Java 8中有很多好的方法实现这种单个方法的匿名类。<br>Lambda表达式</p>
<p>先看看传统Java的代码例子：</p>
<p>List<string> names = Arrays.asList(“peter”, “anna”, “mike”, “xenia”);</string></p>
<p>Collections.sort(names, new Comparator<string>() {</string></p>
<pre><code>@Override
public int compare(String a, String b) {
    return b.compareTo(a);
}
</code></pre><p>});</p>
<p>静态方法Collections.sort接受一个集合List和一个比较器comparator，后者是为了对集合中元素排序，一般我们都是创建一个匿名的比较器对象传递集合中。</p>
<p>Java 8使用Lambda表达式替代这种匿名类。</p>
<p>Collections.sort(names, (String a, String b) -&gt; {</p>
<pre><code>return b.compareTo(a);
</code></pre><p>});</p>
<p>代码相对简短，还可以再短小些：</p>
<p>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</p>
<p>对于只有一个方法，你可以忽略{} 和 return语法，当然还可以再简短：</p>
<p>Collections.sort(names, (a, b) -&gt; b.compareTo(a));</p>
<p>Java编译器会照顾你忽略了a和b的类型String。这称为语言的类型判断。</p>
<p>函数接口</p>
<p>Lambda表达式是一种函数语法，与Java的类型语言是两种不同性质的语法，如同南北两个不同方向，那么Java 8的Lambda表达式如何配合Java天生的类型系统呢？每个Lambda都对应一个给定的类型，主要是一个接口类型，也称为函数接口，只能包含一个抽象方法，每个类型的Lambda表达式与这个抽象方法匹配，因为默认default方法不是抽象方法，你可以在接口中自由增加自定义的default默认方法。</p>
<p>我们可以使用很多接口作为lambda表达式，只要这个接口只包含一个抽象方法，为了确保你的接口符合需要，你应当加入元注解 @FunctionalInterface. 编译器将会注意到这个元注解，如果你试图增加第二个抽象方法到接口中，它会抛出编译错误。</p>
<p>@FunctionalInterface</p>
<p>interface Converter<f, t=""> {</f,></p>
<pre><code>T convert(F from);
</code></pre><p>}</p>
<p>Converter<string, integer=""> converter = (from) -&gt; Integer.valueOf(from);<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);    // 123</string,></p>
<p>这段代码中，我们定义了接口Converter一个抽象方法，注意虽然使用了@FunctionalInterface ，但是不使用也是可以，那么这个接口中抽象方法就可以作为Lambda表达式使用，首先，我们定义了这个接口的实现：</p>
<p>Converter<string, integer=""> converter = (from) -&gt; Integer.valueOf(from);</string,></p>
<p>(from) -&gt; Integer.valueOf(from)实际是抽象方法 T convert(F from)的实现具体细节，这里是将字符串转换为整数型。</p>
<p>然后，我们就可以直接调用这个接口：converter.convert(“123”)</p>
<p>方法和构造器的引用</p>
<p>上述代码如果使用静态方法引用static method references将会更加简化：</p>
<p>Converter<string, integer=""> converter = Integer::valueOf;<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);   // 123</string,></p>
<p>Java 8 使用符号 ::让你传递方法或构造器的引用，因为 Integer.valueOf是一个静态方法，其引用方式是 Integer::valueOf，我们还能引用一个对象的普通方法：</p>
<p>class Something {</p>
<pre><code>String startsWith(String s) {

    return String.valueOf(s.charAt(0));

}
</code></pre><p>}</p>
<p>Something something = new Something();<br>Converter<string, string=""> converter = something::startsWith;<br>String converted = converter.convert(“Java”);<br>System.out.println(converted);    // “J”</string,></p>
<p>这里引用的是类Something的方法startsWith，我们首先要创建这个类的实例，然后使用something::startsWith，这相当于实现了接口Converter的convert方法。不必像我们传统方式，通过Something implements Converter，然后在具体实现Converter的抽象方法convert。这样摆脱了子类对接口的依赖。</p>
<p>符号::也可以使用在构造器方法中：</p>
<p>class Person {</p>
<pre><code>String firstName;
String lastName;
Person() {}

Person(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;

}
</code></pre><p>}</p>
<p>下面是创建Person的工厂接口：</p>
<p>interface PersonFactory</p><p extends="" person=""> {</p>
<pre><code>P create(String firstName, String lastName);
</code></pre><p>}</p>
<p>有别于传统手工实现这个接口的方式，我们使用::将接口和实现粘合在一起。</p>
<p>PersonFactory<person> personFactory = Person::new;<br>Person person = personFactory.create(“Peter”, “Parker”);</person></p>
<p>我们使用Person::new创建了一个指向Person构造器的引用，Java编译器将会自动挑选匹配PersonFactory.create方法签名的构造器。</p>
<p>Lambda作用域</p>
<p>从Lambda表达式访问外部变量非常类似匿名对象访问外部一样，匿名对象只能访问外部访问有final定义的变量。<br>访问本地变量:</p>
<p>final int num = 1;<br>Converter<integer, string=""> stringConverter =   (from) -&gt; String.valueOf(from + num);<br>stringConverter.convert(2);   </integer,></p>
<p>这里(from) -&gt; String.valueOf(from + num)表达式 访问了外部的变量num，区别于匿名类，这个变量不是必须加上final定义。下面也可以：</p>
<p>int num = 1;<br>Converter<integer, string=""> stringConverter =  (from) -&gt; String.valueOf(from + num);</integer,></p>
<p>这就是Lambda表达式比匿名类的好处。但是这不代表你可以修改num值，这里是隐式的final，下面语法是不可以的：</p>
<p>int num = 1;<br>Converter<integer, string=""> stringConverter =   (from) -&gt; String.valueOf(from + num);<br>num = 3;</integer,></p>
<p>一旦被写入了Lambda表达式的变量不能再被修改了。<br>访问字段和静态变量</p>
<p>正好和本地变量相反，我们在Lambda表达式中可以对实例的字段和静态变量进行读和写。无论这个字段或静态变量是否在lambda表达式中使用过。</p>
<p>class Lambda4 {</p>
<pre><code>static int outerStaticNum;
int outerNum;

void testScopes() {

    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {
        outerNum = 23;
        return String.valueOf(from);
    };

    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {
        outerStaticNum = 72;
        return String.valueOf(from);
    };
}
</code></pre><p>}<br>访问接口的默认方法</p>
<p>还记得开始的formula案例吗？接口Formula定义了一个默认方法sqrt，它可以被匿名对象访问 ，但是不能被Lambda表达式访问。</p>
<p>默认方法不能在Lambda表达式中访问，下面代码不会编译通过：</p>
<p>Formula formula = (a) -&gt; sqrt( a * 100);</p>
<p>前面谈了java8的lambda，现在来了解Java8的Monad，Monad是范畴理论中一个词语，但是就像我们吃披萨不用到意大利一样，不学习饶舌的范畴论我们也可以理解Monad。范畴论中是如此隐晦地定义：</p>
<p>a monad in X is just a monoid in the category of endofunctors of X。</p>
<p>翻译软件都不知道单词endofunctors 。了解了闭包 Lambda，我们基本可以理解Monad是一个个lambda串联起来，说得标准一些，如下：</p>
<p>A monad is a structure that puts a value in a computational context</p>
<p>Monad是一种结构，这种结构能够将一个值放入一个可计算的上下文中。因为Lambda是一个和上下文环境有关的表达式，所以，这里对Monad的上下文理解就比较容易。</p>
<p>　　scala中的map就是一个monad，见：Scala入门之函数编程。下面我们看看在java8中如何自己实现一个monad。</p>
<p>M<a> unit(A a);<br>M<b> bind(M<a> ma, Function<a, m<b="">&gt; f);</a,></a></b></a></p>
<p>interface M {<br>　M<b> map(Function<a, b=""> f){<br>　　return flatMap( x -&gt; unit( f.apply(x) ) );//<br>　}<br>　M<b> flatMap(Function<a, m<b="">&gt; f);<br>}</a,></b></a,></b></p>
<p>这里的map定义了一个monad，将flatMap和Unit绑定组合(串联)在一起。</p>
<p>　　下面看看monad的好处，假设有三个类，有关车的保险名称：</p>
<p>public class Person {<br>　private Car car;<br>　public Car getCar() { return car; }<br>}<br>public class Car {<br>　private Insurance insurance;<br>　public Insurance getInsurance() { return insurance; }<br>}<br>public class Insurance {<br>　private String name;<br>　public String getName() { return name; }<br>}</p>
<p>这里Insurance是保险，里面有保险名字，为了得到某个人的车辆的保险名字，需要下面：</p>
<p>String getCarInsuranceName(Person person) {<br>　if (person != null) {<br>　　Car car = person.getCar();<br>　　if (car != null) {<br>　　　Insurance insurance = car.getInsurance;<br>　　　if (insurance != null) {<br>　　　　return insurance.getName()<br>　　　}<br>　　}<br>　}<br>　return “Unknown”;<br>}</p>
<p>需要经过很深入嵌套式的判断然后才能返回。</p>
<p>　　我们首先定义一个Optional　：</p>
<p>public class Optional<t> {<br>　private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;(null);<br>　private final T value;<br>　private Optional(T value) {<br>　　this.value = value;<br>　}<br>　public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; f) {<br>　　return value == null ? EMPTY : new Optional(f.apply(value));<br>　}<br>　public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; f) {<br>　　return value == null ? EMPTY : f.apply(value);<br>　}<br>}</u></u></u></u></u></t></p>
<p>然后对前面三个模型重新编写，加入Optional:</p>
<p>public class Person {<br>　private Optional<car> car;<br>　public Optional<car> getCar() { return car; }<br>}<br>public class Car {<br>　private Optional<insurance> insurance;<br>　public Optional<insurance> getInsurance() { return insurance; }<br>}<br>public class Insurance {<br>　private String name;<br>　public String getName() { return name; }<br>}</insurance></insurance></car></car></p>
<p>寻找一个人的车辆保险名字的查询如下：</p>
<p>String getCarInsuranceName(Optional<person> person) {<br>　return person.flatMap(person -&gt; person.getCar())<br>　　　　　　　.flatMap(car -&gt; car.getInsurance())<br>　　　　　　　.map(insurance -&gt; insurance.getName())<br>　　　　　　　.orElse(“Unknown”);<br>}</person></p>
<p>第一句：person.flatMap(person -&gt; person.getCar()) 得到的是 Optional<car>类型的car.</car></p>
<p>.flatMap(car -&gt; car.getInsurance())得到的是Optional<insurance>的Insurance;</insurance></p>
<p>.map(insurance -&gt; insurance.getName())</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/java/">java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/new-feature/">new feature</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://silveringsea.github.io/2015/07/05/java8/" data-title="java8 | silveringsea on the run" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/07/14/php-config/" title="php configuration">
  <strong>上一篇：</strong><br/>
  <span>
  php configuration</span>
</a>
</div>


<div class="next">
<a href="/2015/07/01/cap-theorem/"  title="cap theorem">
 <strong>下一篇：</strong><br/> 
 <span>cap theorem
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2015/07/05/java8/" data-title="java8" data-url="http://silveringsea.github.io/2015/07/05/java8/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"silveringsea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional"><span class="toc-number">1.</span> <span class="toc-text">Optional</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/android/" title="android">android<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/ios/" title="ios">ios<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>20</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/nosql/" title="nosql">nosql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/osx/" title="osx">osx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/settings/" title="settings">settings<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/test/" title="test">test<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/thorem/" title="thorem">thorem<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/tools/" title="tools">tools<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/java/" title="java">java<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/tools/" title="tools">tools<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/test/" title="test">test<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/new-feature/" title="new feature">new feature<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nosql/" title="nosql">nosql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/development-tools/" title="development tools">development tools<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/settings/" title="settings">settings<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/websocket/" title="websocket">websocket<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/activemq/" title="activemq">activemq<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vim-tools/" title="vim, tools">vim, tools<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/zookeeper/" title="zookeeper">zookeeper<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/tomcat/" title="tomcat">tomcat<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/apache/" title="apache">apache<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/netty/" title="netty">netty<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://iteye.com" target="_blank" title="iteye">iteye</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Rony running on silveringsea <br/>
			Help and be yourself</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1921609945" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="silveringsea">silveringsea</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"silveringsea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>


<script src="/js/ua-parser.js"></script>
<script type="text/javascript">
$(function() {
  if (typeof DUOSHUO !== 'undefined')hookDUOSHUO_tp();
  else $('[src="http://static.duoshuo.com/embed.js"]')[0].onload=hookDUOSHUO_tp;
});
function hookDUOSHUO_tp(){
    var _D_post=DUOSHUO.templates.post
    DUOSHUO.templates.post=function (e,t){
        var rs=_D_post(e,t);
        var agent=e.post.agent;
        if(agent&&/^Mozilla/.test(agent))rs=rs.replace(/<\/div><p>/,show_ua(agent)+'</div><p>');
        return rs;
    }
}
function show_ua(string){
    //console.log(string)
    $.ua.set(string);
    var sua=$.ua;
    if(sua.os.version=='x86_64')sua.os.version='x64';
    return '<span class="this_ua platform '+sua.os.name+'">'+sua.os.name+' '+sua.os.version+'</span><span class="this_ua browser '+sua.browser.name+'">'+sua.browser.name+'|'+sua.browser.version+'</span>';
}
</script>

<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
