
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>silveringsea on the run</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="silveringsea">
    

    
    <meta name="description" content="科学，技术，点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="silveringsea on the run">
<meta property="og:url" content="http://silveringsea.github.io/page/11/index.html">
<meta property="og:site_name" content="silveringsea on the run">
<meta property="og:description" content="科学，技术，点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="silveringsea on the run">
<meta name="twitter:description" content="科学，技术，点滴">

    
    <link rel="alternative" href="/atom.xml" title="silveringsea on the run" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="silveringsea on the run" title="silveringsea on the run"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="silveringsea on the run">silveringsea on the run</a></h1>
				<h2 class="blog-motto">going forward</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页 | Home</a></li>
					
						<li><a href="/archives">归档 | Archives</a></li>
					
						<li><a href="/about">简介 | About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:silveringsea.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/14/php-config/" title="php configuration" itemprop="url">php configuration</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-07-14T12:54:29.000Z" itemprop="datePublished"> 发表于 2015-07-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="php_u6709_u7528_u7684_u547D_u4EE4"><a href="#php_u6709_u7528_u7684_u547D_u4EE4" class="headerlink" title="php有用的命令"></a>php有用的命令</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php-config</span><br><span class="line">phpize</span><br><span class="line">php -m</span><br><span class="line">php -r <span class="string">"phpinfo();"</span><span class="string">|grep ini</span></span><br><span class="line">php --ini</span><br></pre></td></tr></table></figure>
<h2 id="php7__u65B0_u7279_u6027_u603B_u7ED3"><a href="#php7__u65B0_u7279_u6027_u603B_u7ED3" class="headerlink" title="php7 新特性总结"></a>php7 新特性总结</h2><h4 id="u63D2_u4EF6"><a href="#u63D2_u4EF6" class="headerlink" title="插件"></a>插件</h4><ol>
<li>igbinary 用 <a href="https://github.com/Sean-Der/igbinary.git" target="_blank" rel="external">https://github.com/Sean-Der/igbinary.git</a> 的php7分支</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/php/">php</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/new-feature/">new feature</a><a href="/tags/php/">php</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/14/php-config/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/14/php-config/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/05/java8/" title="java8" itemprop="url">java8</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-07-05T01:29:30.000Z" itemprop="datePublished"> 发表于 2015-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>　　Java 8中的Optional<t>是一个可以包含或不可以包含非空值的容器对象，在 Stream API中很多地方也都使用到了Optional。</t></p>
<p>　　java中非常讨厌的一点就是nullpoint，碰到空指针就会出错抛Exception，然后需要逐行检查是哪个对象为空，带来大量的不必要精力损耗，抛出NPE错误不是用户操作的错误，而是开发人员的错误，应该被避免，那么只能在每个方法中加入非空检查，阅读性和维护性都比较差。</p>
<p>　　如下面这个代码的手工非空检查：<br>public void addAddressToCustomer(Customer customer, Address newAddress){<br> if ( customer == null || newAddress == null)<br> return;</p>
<p> if ( customer.getAddresses() == null ){<br>   customer.setAddresses ( new ArrayList&lt;&gt;());<br> }<br> customer.addAddress(newAddress);<br>}</p>
<p>　　另外还有一些开发人员喜欢通过非空检查来实现业务逻辑，空对象不应该用来决定系统的行为，它们是意外的Exceptional值，应当被看成是错误，而不是业务逻辑状态。</p>
<p>　　当我们一个方法返回List集合时，应该总是返回一个空的List，而不是Null，这就允许调用者能够遍历它而不必检查Null，否则就抛出NPE。</p>
<p>　　但是如果我们根据标识键ID查询数据库，没有查到，需要返回一个空对象怎么办？有人建议抛出Exception，其实这不符合函数方法一进一出的原则，变成一个函数方法有两个返回，一个是正常返回，一个出错Exception，函数式编程范式告诫我们不要轻易抛Exception。</p>
<p>　　这时Java 8的Optional就发挥作用了，允许我们返回一个空的对象。</p>
<p>　　Optional<t>有方法 isPresent() 和 get() 是用来检查其包含的对象是否为空或不是，然后返回它，如：</t></p>
<p>Optional<sometype> someValue = someMethod();</sometype></p>
<p>if (someValue.isPresent()) { // check</p>
<pre><code>someValue.get().someOtherMethod(); // retrieve and call
</code></pre><p>}</p>
<p>　　但是这种用法并不能体现Java 8的全部好处，你可以将Optional看成是需要使用某个T值的方法之间某种中间人或者协调者Mediator，而不只是一个普通对象的包装器。</p>
<p>　　如果你有一个值返回类型T，你有一个方法需要使用这个值，那么你可以让 Optional<t> 处于中间，确保它们之间交互进行，而不必要人工干预。</t></p>
<p>　　这样，协调者Optional<t>能够照顾T的值提供给你的方法作为输入参数，在这种情况下，如果T是空，可以确保不会出错，这样在T值为空时也可以让一切都正常运作，你也可以让Optional<t>执行其他动作，如执行一段代码块等等，这样它就实际上是语言机制的很好的补充。</t></t></p>
<p>　　下面这个案例涉及到Lambda表达式 方法引用，是将单词流中第一个以”L”开始单词取出，作为返回结果是一个Optional<string>。<br>使用ifPresent()</string></p>
<p>　　这个案例的代码如下：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;L&quot;))

.findFirst();
</code></pre><p>longest.ifPresent(name -&gt; {</p>
<pre><code>    String s = name.toUpperCase();

    System.out.println(&quot;The longest name is &quot;+ s);

});
</code></pre><p>　　这里ifPresent() 是将一个Lambda表达式作为输入，T值如果不为空将传入这个lambda。那么这个lambda将不为空的单词转为大写输出显示。在前面names单词流寻找结果中，有可能找不到开始字母为L的单词，返回为空，也可能找到不为空，这两种情况都传入lambda中，无需我们打开盒子自己编写代码来判断，它自动帮助我们完成了，无需人工干预。</p>
<p>使用map()</p>
<p>　　如果你想从Optional<t>中返回一个值怎么办？使用 map()，如下：</t></p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;L&quot;))

.findFirst();
</code></pre><p>Optional<string> lNameInCaps = longest.map(String::toUpperCase);</string></p>
<p>　　使用Optional<t>的map方法能够返回另外一个Optional，如上面的 LnameInCaps，因为传入map()的参数值也许会导致一个空值。</t></p>
<p>使用orElse()</p>
<p>　　如果在T可能空时你需要一个值的话，那么可以使用 orElse()，它能在T值存在的情况下返回这个值，否则返回输入值。</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p> String alternate = longest.orElse(“Nimrod”);</p>
<p> System.out.println(alternate); //prints out “Nimrod”</p>
<p>使用orElseGet()</p>
<p>　　orElseGet() 方法类似于orElse()，但是不是直接返回输入参数，而是调用输入参数，返回调用的结果，这个输入参数通常是lambda：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p>Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p> String alternate = longest.orElseGet(() -&gt; {</p>
<pre><code>// perform some interesting code operation

// then return the alternate value.

return &quot;Nimrod&quot;;
</code></pre><p> });</p>
<p> System.out.println(alternate);</p>
<p>使用 orElseThrow()</p>
<p>　　orElseThrow()是在当遭遇Null时，决定抛出哪个Exception时使用：</p>
<p>Stream<string> names = Stream.of(“Lamurudu”, “Okanbi”, “Oduduwa”);</string></p>
<p> Optional<string> longest = names</string></p>
<pre><code>.filter(name -&gt; name.startsWith(&quot;Q&quot;))

.findFirst();
</code></pre><p>longest.orElseThrow(NoSuchElementStartingWithQException::new);</p>
<p>总结，你能创建下面三种类型的Optional<t>：</t></p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>// 返回一个空的Optional类型;</p>
<p>return Optional.empty();</p>
<p>}</p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>SomeType value = …;</p>
<p>// 使用这个方法，值不可以为空，否则抛exception</p>
<p>return Optional.of(value);</p>
<p>}</p>
<p>Optional<sometype> getSomeValue() {</sometype></p>
<p>SomeType value = …;</p>
<p>// 使用这个方法，值可以为空，如果为空返回Optional.empty</p>
<p>return Optional.ofNullable(value);</p>
<p>// usage</p>
<p>Optional<sometype> someType = getSomeValue();</sometype></p>
<p>首先创建一个函数接口ResultSetProcessor ：</p>
<p>@FunctionalInterface<br>public interface ResultSetProcessor {</p>
<pre><code>public void process(ResultSet resultSet,
                    long currentRow)
                    throws SQLException;
</code></pre><p>}</p>
<p>下面做个简单查询案例，使用这个接口遍历</p>
<p>public static void select(Connection connection,<br>                          String sql,<br>                          ResultSetProcessor processor,<br>                          Object… params) {<br>        try (PreparedStatement ps = connection.prepareStatement(sql)) {<br>            int cnt = 0;<br>            for (Object param : params) {<br>                ps.setObject(++cnt, param));<br>            }<br>            try (ResultSet rs = ps.executeQuery()) {<br>                long rowCnt = 0;<br>                while (rs.next()) {<br>                    processor.process(rs, rowCnt++);<br>                }<br>            } catch (SQLException e) {<br>                throw new DataAccessException(e);<br>            }<br>        } catch (SQLException e) {<br>            throw new DataAccessException(e);<br>        }<br>}</p>
<p>调用这个select语句如下：</p>
<p>select(connection, “select * from MY_TABLE”,(rs, cnt)-&gt; {<br>   System.out.println(rs.getInt(1)+” “+cnt)<br>});</p>
<p>select的第三个参数ResultSetProcessor这是个函数，所以我们传入的是一个匿名函数。<br> Streams API</p>
<p>　　　java 8提供了更强大的 Streams API,我们可以对ResultSet处理更加强大。创建一个自己的Tuple 类型，代表ResultSet中一行记录。</p>
<p>　　　下面我们将一个查询和ResultSet包装在一个Iterator中：</p>
<p>public class ResultSetIterator implements Iterator {</p>
<pre><code>private ResultSet rs;
private PreparedStatement ps;
private Connection connection;
private String sql;

public ResultSetIterator(Connection connection, String sql) {
    assert connection != null;
    assert sql != null;
    this.connection = connection;
    this.sql = sql;
}

public void init() {
    try {
        ps = connection.prepareStatement(sql);
        rs = ps.executeQuery();

    } catch (SQLException e) {
        close();
        throw new DataAccessException(e);
    }
}

@Override
public boolean hasNext() {
    if (ps == null) {
        init();
    }
    try {
        boolean hasMore = rs.next();
        if (!hasMore) {
            close();
        }
        return hasMore;
    } catch (SQLException e) {
        close();
        throw new DataAccessException(e);
    }

}

private void close() {
    try {
        rs.close();
        try {
            ps.close();
        } catch (SQLException e) {
            //nothing we can do here
        }
    } catch (SQLException e) {
        //nothing we can do here
    }
}

@Override
public Tuple next() {
    try {
        return SQL.rowAsTuple(sql, rs);
    } catch (DataAccessException e) {
        close();
        throw e;
    }
}
</code></pre><p>}</p>
<p>这是一个遍历器，每次返回ResultSet的一行记录，返回类型是我们定义Tuple.</p>
<p>关于tuple定义可见源码。</p>
<p>我们和Stream绑定在一起如下：</p>
<p>public static Stream stream(final Connection connection,<br>                                       final String sql,<br>                                       final Object… parms) {<br>  return StreamSupport<br>                .stream(Spliterators.spliteratorUnknownSize(<br>                        new ResultSetIterator(connection, sql), 0), false);<br>}</p>
<p>Java 8 提供StreamSupport静态方法.stream来创建 java.util.stream.Stream实例，同时还需要java.util.stream.Spliterator，这是一个用来遍历和分区一个序列元素(集合)的特殊类型，有了它才能并行处理我们饿操作，而Spliterators 这是能够对已经存在的集合如java.util.Iterator.提供并行操作。</p>
<p>我们调用上面stream如下：</p>
<p>long result = stream(connection, “select TEST_ID from TEST_TABLE”)<br>           .filter((t) -&gt; t.asInt(“TEST_ID”) % 2 == 0)<br>           .limit(100)<br>           .count();</p>
<p>这是查询所有的TEST_ID,然后过滤掉所有非偶数，最后再运行一个计数。非常简单明了。如果你使用ORM/JPA等框架，可能无法让自己的SQL代码如此优雅直接了，它类似Hibernate的 criteria。</p>
<p> <a href="https://github.com/jexenberger/lambda-tuples" target="_blank" rel="external">https://github.com/jexenberger/lambda-tuples</a></p>
<p><a href="http://www.jdon.com/idea/java/java-8-lambda-jdbc.html" target="_blank" rel="external">java8</a></p>
<ol>
<li>实现Runnable线程案例</li>
</ol>
<p>使用() -&gt; {} 替代匿名类：</p>
<p>//Before Java 8:<br>new Thread(new Runnable() {<br>    @Override<br>    public void run() {<br>        System.out.println(“Before Java8 “);<br>    }<br>}).start();</p>
<p>//Java 8 way:<br>new Thread( () -&gt; System.out.println(“In Java8!”) ).start();</p>
<p>Output:<br>too much code, for too little to do<br>Lambda expression rocks !!</p>
<p>你可以使用 下面语法实现Lambda:</p>
<p>(params) -&gt; expression<br>(params) -&gt; statement<br>(params) -&gt; { statements }</p>
<p>如果你的方法并不改变任何方法参数，比如只是输出，那么可以简写如下：<br>() -&gt; System.out.println(“Hello Lambda Expressions”);</p>
<p>如果你的方法接受两个方法参数，如下：</p>
<p>(int even, int odd) -&gt; even + odd</p>
<p>2.实现事件处理</p>
<p>如果你曾经做过Swing 编程，你将永远不会忘记编写事件侦听器代码。使用lambda表达式如下所示写出更好的事件侦听器的代码。</p>
<p>// Before Java 8:<br>JButton show =  new JButton(“Show”);<br>show.addActionListener(new ActionListener() {<br>     @Override<br>     public void actionPerformed(ActionEvent e) {<br>           System.out.println(“without lambda expression is boring”);<br>        }<br>     });</p>
<p>// Java 8 way:<br>show.addActionListener((e) -&gt; {<br>    System.out.println(“Action !! Lambda expressions Rocks”);<br>});</p>
<p>在java 8中你可以使用Lambda表达式替代丑陋的匿名类。</p>
<p>3.使用Lambda表达式遍历List集合</p>
<p>//Prior Java 8 :<br>List features = Arrays.asList(“Lambdas”, “Default Method”,<br>“Stream API”, “Date and Time API”);<br>for (String feature : features) {<br>   System.out.println(feature);<br>}</p>
<p>//In Java 8:<br>List features = Arrays.asList(“Lambdas”, “Default Method”, “Stream API”,<br> “Date and Time API”);<br>features.forEach(n -&gt; System.out.println(n));</p>
<p>// Even better use Method reference feature of Java 8<br>// method reference is denoted by :: (double colon) operator<br>// looks similar to score resolution operator of C++<br>features.forEach(System.out::println);</p>
<p>Output:<br>Lambdas<br>Default Method<br>Stream API<br>Date and Time API</p>
<p>方法引用是使用两个冒号::这个操作符号。<br>4.使用Lambda表达式和函数接口</p>
<p>为了支持函数编程，Java 8加入了一个新的包java.util.function，其中有一个接口java.util.function.Predicate是支持Lambda函数编程：</p>
<p>public static void main(args[]){<br>  List languages = Arrays.asList(“Java”, “Scala”, “C++”, “Haskell”, “Lisp”);</p>
<p>  System.out.println(“Languages which starts with J :”);<br>  filter(languages, (str)-&gt;str.startsWith(“J”));</p>
<p>  System.out.println(“Languages which ends with a “);<br>  filter(languages, (str)-&gt;str.endsWith(“a”));</p>
<p>  System.out.println(“Print all languages :”);<br>  filter(languages, (str)-&gt;true);</p>
<p>   System.out.println(“Print no language : “);<br>   filter(languages, (str)-&gt;false);</p>
<p>   System.out.println(“Print language whose length greater than 4:”);<br>   filter(languages, (str)-&gt;str.length() &gt; 4);<br>}</p>
<p> public static void filter(List names, Predicate condition) {<br>    for(String name: names)  {<br>       if(condition.test(name)) {<br>          System.out.println(name + “ “);<br>       }<br>    }<br>  }<br>}</p>
<p>Output:<br>Languages which starts with J :<br>Java<br>Languages which ends with a<br>Java<br>Scala<br>Print all languages :<br>Java<br>Scala<br>C++<br>Haskell<br>Lisp<br>Print no language :<br>Print language whose length greater than 4:<br>Scala<br>Haskell</p>
<p>//Even better<br> public static void filter(List names, Predicate condition) {<br>    names.stream().filter((name) -&gt; (condition.test(name)))<br>        .forEach((name) -&gt; {System.out.println(name + “ “);<br>    });<br> }</p>
<p>你能看到来自Stream API 的filter方法能够接受 Predicate参数, 能够允许测试多个条件。</p>
<p>5.复杂的结合Predicate 使用</p>
<p>java.util.function.Predicate提供and(), or() 和 xor()可以进行逻辑操作，比如为了得到一串字符串中以”J”开头的4个长度：</p>
<p>// We can even combine Predicate using and(), or() And xor() logical functions<br> // for example to find names, which starts with J and four letters long, you<br> // can pass combination of two Predicate<br> Predicate<string> startsWithJ = (n) -&gt; n.startsWith(“J”);<br> Predicate<string> fourLetterLong = (n) -&gt; n.length() == 4;</string></string></p>
<p> names.stream()<br>      .filter(startsWithJ.and(fourLetterLong))<br>      .forEach((n) -&gt; System.out.print(“\nName, which starts with<br>            ‘J’ and four letter long is : “ + n));</p>
<p>其中startsWithJ.and(fourLetterLong)是使用了AND逻辑操作。</p>
<p>6.使用Lambda实现Map 和 Reduce</p>
<p>最流行的函数编程概念是map，它允许你改变你的对象，在这个案例中，我们将costBeforeTeax集合中每个元素改变了增加一定的数值，我们将Lambda表达式 x -&gt; x*x传送map()方法，这将应用到stream中所有元素。然后我们使用 forEach() 打印出这个集合的元素.</p>
<p>// applying 12% VAT on each purchase<br>// Without lambda expressions:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>for (Integer cost : costBeforeTax) {<br>      double price = cost + .12*cost;<br>      System.out.println(price);<br>}</p>
<p>// With Lambda expression:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>costBeforeTax.stream().map((cost) -&gt; cost + .12*cost)<br>                      .forEach(System.out::println);</p>
<p>Output<br>112.0<br>224.0<br>336.0<br>448.0<br>560.0<br>112.0<br>224.0<br>336.0<br>448.0<br>560.0</p>
<p>reduce() 是将集合中所有值结合进一个，Reduce类似SQL语句中的sum(), avg() 或count(), </p>
<p>// Applying 12% VAT on each purchase<br>// Old way:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>double total = 0;<br>for (Integer cost : costBeforeTax) {<br> double price = cost + .12*cost;<br> total = total + price;</p>
<p>}<br>System.out.println(“Total : “ + total);</p>
<p>// New way:<br>List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);<br>double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost)<br>                                    .reduce((sum, cost) -&gt; sum + cost)<br>                                    .get();<br>System.out.println(“Total : “ + bill);</p>
<p>Output<br>Total : 1680.0<br>Total : 1680.0</p>
<p>7.通过filtering 创建一个字符串String的集合</p>
<p>Filtering是对大型Collection操作的一个通用操作，Stream提供filter()方法，接受一个Predicate对象，意味着你能传送lambda表达式作为一个过滤逻辑进入这个方法：</p>
<p>// Create a List with String more than 2 characters<br>List<string> filtered = strList.stream().filter(x -&gt; x.length()&gt; 2)<br>                                        .collect(Collectors.toList());<br>System.out.printf(“Original List : %s, filtered list : %s %n”,<br>                  strList, filtered);</string></p>
<p>Output :<br>Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</p>
<p>8.对集合中每个元素应用函数</p>
<p>我们经常需要对集合中元素运用一定的功能，如表中的每个元素乘以或除以一个值等等.</p>
<p>// Convert String to Uppercase and join them using coma<br>List<string> G7 = Arrays.asList(“USA”, “Japan”, “France”, “Germany”,<br>                                “Italy”, “U.K.”,”Canada”);<br>String G7Countries = G7.stream().map(x -&gt; x.toUpperCase())<br>                                .collect(Collectors.joining(“, “));<br>System.out.println(G7Countries);</string></p>
<p>Output :<br>USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</p>
<p>上面是将字符串转换为大写，然后使用逗号串起来。</p>
<p>9.通过复制不同的值创建一个子列表</p>
<p>使用Stream的distinct()方法过滤集合中重复元素。</p>
<p>// Create List of square of all distinct numbers<br>List<integer> numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);<br>List<integer> distinct = numbers.stream().map( i -&gt; i*i).distinct()<br>                                         .collect(Collectors.toList());<br>System.out.printf(“Original List : %s,  Square Without duplicates :<br>                   %s %n”, numbers, distinct);</integer></integer></p>
<p>Output :<br>Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without<br>                                         duplicates : [81, 100, 9, 16, 49]</p>
<p>10.计算List中的元素的最大值，最小值，总和及平均值</p>
<p>//Get count, min, max, sum, and average for numbers<br>List<integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);<br>IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x)<br>                                            .summaryStatistics();<br>System.out.println(“Highest prime number in List : “ + stats.getMax());<br>System.out.println(“Lowest prime number in List : “ + stats.getMin());<br>System.out.println(“Sum of all prime numbers : “ + stats.getSum());<br>System.out.println(“Average of all prime numbers : “ + stats.getAverage());</integer></p>
<p>Output :<br>Highest prime number in List : 29<br>Lowest prime number in List : 2<br>Sum of all prime numbers : 129<br>Average of all prime numbers : 12.9</p>
<p> 在本教程中主要讲解Java 8新的函数式编程功能，熟悉这些新的 API：streams, 函数接口, map扩展和新的日期API。<br>接口的缺省方法</p>
<p>Java 8让我们能够增加非抽象方法实现到一个接口中， 使用default，这个特点就是 Extension Methods.</p>
<p>interface Formula {</p>
<pre><code>double calculate(int a);
default double sqrt(int a) {
    return Math.sqrt(a);
}
</code></pre><p>}</p>
<p>接口 Formula 定义了一个默认方法sqrt. 该接口实现类只要完成接口中抽象方法calculate即可，而sqrt方法可以被外部使用。</p>
<p>ormula formula = new Formula() {</p>
<pre><code>@Override
public double calculate(int a) {
    return sqrt(a * 100);
}
</code></pre><p>};</p>
<p>formula.calculate(100);     // 100.0<br>formula.sqrt(16);           // 4.0</p>
<p>代码中formula 实现类是一个匿名类，在Java 8中有很多好的方法实现这种单个方法的匿名类。<br>Lambda表达式</p>
<p>先看看传统Java的代码例子：</p>
<p>List<string> names = Arrays.asList(“peter”, “anna”, “mike”, “xenia”);</string></p>
<p>Collections.sort(names, new Comparator<string>() {</string></p>
<pre><code>@Override
public int compare(String a, String b) {
    return b.compareTo(a);
}
</code></pre><p>});</p>
<p>静态方法Collections.sort接受一个集合List和一个比较器comparator，后者是为了对集合中元素排序，一般我们都是创建一个匿名的比较器对象传递集合中。</p>
<p>Java 8使用Lambda表达式替代这种匿名类。</p>
<p>Collections.sort(names, (String a, String b) -&gt; {</p>
<pre><code>return b.compareTo(a);
</code></pre><p>});</p>
<p>代码相对简短，还可以再短小些：</p>
<p>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</p>
<p>对于只有一个方法，你可以忽略{} 和 return语法，当然还可以再简短：</p>
<p>Collections.sort(names, (a, b) -&gt; b.compareTo(a));</p>
<p>Java编译器会照顾你忽略了a和b的类型String。这称为语言的类型判断。</p>
<p>函数接口</p>
<p>Lambda表达式是一种函数语法，与Java的类型语言是两种不同性质的语法，如同南北两个不同方向，那么Java 8的Lambda表达式如何配合Java天生的类型系统呢？每个Lambda都对应一个给定的类型，主要是一个接口类型，也称为函数接口，只能包含一个抽象方法，每个类型的Lambda表达式与这个抽象方法匹配，因为默认default方法不是抽象方法，你可以在接口中自由增加自定义的default默认方法。</p>
<p>我们可以使用很多接口作为lambda表达式，只要这个接口只包含一个抽象方法，为了确保你的接口符合需要，你应当加入元注解 @FunctionalInterface. 编译器将会注意到这个元注解，如果你试图增加第二个抽象方法到接口中，它会抛出编译错误。</p>
<p>@FunctionalInterface</p>
<p>interface Converter<f, t=""> {</f,></p>
<pre><code>T convert(F from);
</code></pre><p>}</p>
<p>Converter<string, integer=""> converter = (from) -&gt; Integer.valueOf(from);<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);    // 123</string,></p>
<p>这段代码中，我们定义了接口Converter一个抽象方法，注意虽然使用了@FunctionalInterface ，但是不使用也是可以，那么这个接口中抽象方法就可以作为Lambda表达式使用，首先，我们定义了这个接口的实现：</p>
<p>Converter<string, integer=""> converter = (from) -&gt; Integer.valueOf(from);</string,></p>
<p>(from) -&gt; Integer.valueOf(from)实际是抽象方法 T convert(F from)的实现具体细节，这里是将字符串转换为整数型。</p>
<p>然后，我们就可以直接调用这个接口：converter.convert(“123”)</p>
<p>方法和构造器的引用</p>
<p>上述代码如果使用静态方法引用static method references将会更加简化：</p>
<p>Converter<string, integer=""> converter = Integer::valueOf;<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);   // 123</string,></p>
<p>Java 8 使用符号 ::让你传递方法或构造器的引用，因为 Integer.valueOf是一个静态方法，其引用方式是 Integer::valueOf，我们还能引用一个对象的普通方法：</p>
<p>class Something {</p>
<pre><code>String startsWith(String s) {

    return String.valueOf(s.charAt(0));

}
</code></pre><p>}</p>
<p>Something something = new Something();<br>Converter<string, string=""> converter = something::startsWith;<br>String converted = converter.convert(“Java”);<br>System.out.println(converted);    // “J”</string,></p>
<p>这里引用的是类Something的方法startsWith，我们首先要创建这个类的实例，然后使用something::startsWith，这相当于实现了接口Converter的convert方法。不必像我们传统方式，通过Something implements Converter，然后在具体实现Converter的抽象方法convert。这样摆脱了子类对接口的依赖。</p>
<p>符号::也可以使用在构造器方法中：</p>
<p>class Person {</p>
<pre><code>String firstName;
String lastName;
Person() {}

Person(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;

}
</code></pre><p>}</p>
<p>下面是创建Person的工厂接口：</p>
<p>interface PersonFactory</p><p extends="" person=""> {</p>
<pre><code>P create(String firstName, String lastName);
</code></pre><p>}</p>
<p>有别于传统手工实现这个接口的方式，我们使用::将接口和实现粘合在一起。</p>
<p>PersonFactory<person> personFactory = Person::new;<br>Person person = personFactory.create(“Peter”, “Parker”);</person></p>
<p>我们使用Person::new创建了一个指向Person构造器的引用，Java编译器将会自动挑选匹配PersonFactory.create方法签名的构造器。</p>
<p>Lambda作用域</p>
<p>从Lambda表达式访问外部变量非常类似匿名对象访问外部一样，匿名对象只能访问外部访问有final定义的变量。<br>访问本地变量:</p>
<p>final int num = 1;<br>Converter<integer, string=""> stringConverter =   (from) -&gt; String.valueOf(from + num);<br>stringConverter.convert(2);   </integer,></p>
<p>这里(from) -&gt; String.valueOf(from + num)表达式 访问了外部的变量num，区别于匿名类，这个变量不是必须加上final定义。下面也可以：</p>
<p>int num = 1;<br>Converter<integer, string=""> stringConverter =  (from) -&gt; String.valueOf(from + num);</integer,></p>
<p>这就是Lambda表达式比匿名类的好处。但是这不代表你可以修改num值，这里是隐式的final，下面语法是不可以的：</p>
<p>int num = 1;<br>Converter<integer, string=""> stringConverter =   (from) -&gt; String.valueOf(from + num);<br>num = 3;</integer,></p>
<p>一旦被写入了Lambda表达式的变量不能再被修改了。<br>访问字段和静态变量</p>
<p>正好和本地变量相反，我们在Lambda表达式中可以对实例的字段和静态变量进行读和写。无论这个字段或静态变量是否在lambda表达式中使用过。</p>
<p>class Lambda4 {</p>
<pre><code>static int outerStaticNum;
int outerNum;

void testScopes() {

    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {
        outerNum = 23;
        return String.valueOf(from);
    };

    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {
        outerStaticNum = 72;
        return String.valueOf(from);
    };
}
</code></pre><p>}<br>访问接口的默认方法</p>
<p>还记得开始的formula案例吗？接口Formula定义了一个默认方法sqrt，它可以被匿名对象访问 ，但是不能被Lambda表达式访问。</p>
<p>默认方法不能在Lambda表达式中访问，下面代码不会编译通过：</p>
<p>Formula formula = (a) -&gt; sqrt( a * 100);</p>
<p>前面谈了java8的lambda，现在来了解Java8的Monad，Monad是范畴理论中一个词语，但是就像我们吃披萨不用到意大利一样，不学习饶舌的范畴论我们也可以理解Monad。范畴论中是如此隐晦地定义：</p>
<p>a monad in X is just a monoid in the category of endofunctors of X。</p>
<p>翻译软件都不知道单词endofunctors 。了解了闭包 Lambda，我们基本可以理解Monad是一个个lambda串联起来，说得标准一些，如下：</p>
<p>A monad is a structure that puts a value in a computational context</p>
<p>Monad是一种结构，这种结构能够将一个值放入一个可计算的上下文中。因为Lambda是一个和上下文环境有关的表达式，所以，这里对Monad的上下文理解就比较容易。</p>
<p>　　scala中的map就是一个monad，见：Scala入门之函数编程。下面我们看看在java8中如何自己实现一个monad。</p>
<p>M<a> unit(A a);<br>M<b> bind(M<a> ma, Function<a, m<b="">&gt; f);</a,></a></b></a></p>
<p>interface M {<br>　M<b> map(Function<a, b=""> f){<br>　　return flatMap( x -&gt; unit( f.apply(x) ) );//<br>　}<br>　M<b> flatMap(Function<a, m<b="">&gt; f);<br>}</a,></b></a,></b></p>
<p>这里的map定义了一个monad，将flatMap和Unit绑定组合(串联)在一起。</p>
<p>　　下面看看monad的好处，假设有三个类，有关车的保险名称：</p>
<p>public class Person {<br>　private Car car;<br>　public Car getCar() { return car; }<br>}<br>public class Car {<br>　private Insurance insurance;<br>　public Insurance getInsurance() { return insurance; }<br>}<br>public class Insurance {<br>　private String name;<br>　public String getName() { return name; }<br>}</p>
<p>这里Insurance是保险，里面有保险名字，为了得到某个人的车辆的保险名字，需要下面：</p>
<p>String getCarInsuranceName(Person person) {<br>　if (person != null) {<br>　　Car car = person.getCar();<br>　　if (car != null) {<br>　　　Insurance insurance = car.getInsurance;<br>　　　if (insurance != null) {<br>　　　　return insurance.getName()<br>　　　}<br>　　}<br>　}<br>　return “Unknown”;<br>}</p>
<p>需要经过很深入嵌套式的判断然后才能返回。</p>
<p>　　我们首先定义一个Optional　：</p>
<p>public class Optional<t> {<br>　private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;(null);<br>　private final T value;<br>　private Optional(T value) {<br>　　this.value = value;<br>　}<br>　public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; f) {<br>　　return value == null ? EMPTY : new Optional(f.apply(value));<br>　}<br>　public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; f) {<br>　　return value == null ? EMPTY : f.apply(value);<br>　}<br>}</u></u></u></u></u></t></p>
<p>然后对前面三个模型重新编写，加入Optional:</p>
<p>public class Person {<br>　private Optional<car> car;<br>　public Optional<car> getCar() { return car; }<br>}<br>public class Car {<br>　private Optional<insurance> insurance;<br>　public Optional<insurance> getInsurance() { return insurance; }<br>}<br>public class Insurance {<br>　private String name;<br>　public String getName() { return name; }<br>}</insurance></insurance></car></car></p>
<p>寻找一个人的车辆保险名字的查询如下：</p>
<p>String getCarInsuranceName(Optional<person> person) {<br>　return person.flatMap(person -&gt; person.getCar())<br>　　　　　　　.flatMap(car -&gt; car.getInsurance())<br>　　　　　　　.map(insurance -&gt; insurance.getName())<br>　　　　　　　.orElse(“Unknown”);<br>}</person></p>
<p>第一句：person.flatMap(person -&gt; person.getCar()) 得到的是 Optional<car>类型的car.</car></p>
<p>.flatMap(car -&gt; car.getInsurance())得到的是Optional<insurance>的Insurance;</insurance></p>
<p>.map(insurance -&gt; insurance.getName())</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/java/">java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/new-feature/">new feature</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/05/java8/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/05/java8/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/01/cap-theorem/" title="cap theorem" itemprop="url">cap theorem</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-07-01T09:49:50.000Z" itemprop="datePublished"> 发表于 2015-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>```<br>目前，CAP（Consistency一致性、Availability可用性、Partition-tolerance分区可容忍性）理论普遍被当作是大数据[注]技术的理论基础。同时根据该理论，业界有一种非常流行和“专业”的认识，那就是：关系型数据库设计选择了C（一致性）与A（可用性），NoSQL数据库设计则不同。其中，HBase选择了C（一致性）与P（分区可容忍性），Cassandra选择了A（可用性）与P（分区可容忍性）。</p>
<p>该说法现在似乎已经成为一种经典认知，无论是初学大数据技术，还是已经有了相当经验的技术人员，都将其奉为真理。大家大概是认为，从CAP这样著名的理论推导出来的结论当然是权威而又正确的，最起码在形式上感觉是专业而又严肃的。有人甚至还将这种认知画成一个三角形图，三个顶点分别是C、A、P，三条边分别是关系型数据库、HBase与Cassandra，这样一来，CAP理论就显然更加神圣了。</p>
<p>实际上，这种认识是不准确，甚至是不正确的。暂且不说深入的分析与研究，只要先从表面上简单分析一下，你就能发现问题：难道说从理论上讲Cassandra就一定比HBase的可用性更高吗？而要彻底搞清楚这个问题，还得先从CAP理论本身开始研究。</p>
<p>常见的理解及分析</p>
<p>目前流行的对CAP理论解释的情形，是从同一数据在网络环境中的多个副本出发的。为了保证数据不会丢失，在企业级的数据管理方案中，一般必须考虑数据的冗余存储问题，而这应该是通过在网络上的其他独立物理存储节点上保留的另一份或多份数据副本来实现的（如附图所示）。因为在同一个存储节点上的数据冗余明显不能解决单点故障问题，这与通过多节点集群来提供更好的计算可用性的道理是相同的。</p>
<p>其实，不用做严格的证明也可以想见，如附图的情况，数据在节点A、B、C上保留了三份，如果对节点A上的数据进行了修改，然后再让客户端通过网络对该数据进行读取。那么，客户端的读取操作应该什么时候返回呢？</p>
<p>有这样两种情况：一种情况是要求节点A、B、C的三份数据完全一致后返回。也就是说，这时从任何一个网络节点读取的数据都是一样的，这就是所谓的强一致性读。很明显，这时数据读取的Latency要高一些（因为要等数据在网络中的复制）。同时，A、B、C三个节点中任何一个宕机，都会导致数据不可用。也就是说，要保证强一致性，网络中的副本越多，数据的可用性就越差。</p>
<p>另一种情况是，允许读操作立即返回，容忍B节点读取与A节点读取不一致的情况发生。这样一来，可用性显然得到了提高，网络中的副本也可以多一些，唯一得不到保证的是数据一致性。当然，对写操作同样也有多个节点一致性的情况，此处不再赘述。</p>
<p>可以看出，上述对CAP理论的解释主要是从网络上多个节点之间的读写一致性出发考虑问题的。而这一点，对于关系型数据库意味着什么呢？当然主要是指通常所说的Standby（关于分布式事务，涉及到更多考虑，随后讨论）情况。对此，在实践中我们大多已经采取了弱一致性的异步延时同步方案，以提高可用性。这种情况并不存在关系型数据库为保证C、A而放弃P的情况。而对海量数据管理的需求，关系型数据库扩展过程中所遇到的性能瓶颈，似乎也并不是CAP理论中所描述的那种原因造成的。那么，上述流行的说法中所描述的关系型数据库为保证C、A而牺牲P到底是在指什么呢？</p>
<p>因此，如果根据现有的大多数资料对CAP理论的如上解释，即只将其当作分布式系统中多个数据副本之间的读写一致性问题的通用理论对待，那么就可以得出结论：CAP既适用于NoSQL数据库，也适用于关系型数据库。它是NoSQL数据库、关系型数据库，乃至一切分布式系统在设计数据多个副本之间读写一致性问题时需要遵循的共同原则。</p>
<p>更深入的探究：</p>
<p>两种重要的分布式场景</p>
<p>在本文中我们要说的重点与核心是：关于对CAP理论中一致性C的理解，除了上述数据副本之间的读写一致性以外，分布式环境中还有两种非常重要的场景，如果不对它们进行认识与讨论，就永远无法全面地理解CAP，当然也就无法根据CAP做出正确的解释。但可惜的是，目前为止却很少有人提及这两种场景：那就是事务与关联。</p>
<p>先来看看分布式环境中的事务场景。我们知道，在关系型数据库的事务操作遵循ACID原则，其中的一致性C，主要是指一个事务中相关联的数据在事务操作结束后是一致的。所谓ACID原则，是指在写入/异动资料的过程中，为保证交易正确可靠所必须具备的四个特性：即原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）和持久性（Durability）。</p>
<p>例如银行的一个存款交易?务，将导致交易流水表增加一条记录，同时账户表余额也必须发生变化，这两个操作必须是在一个事务中全部完成，以保证相关数据的一致性。而前文解释的CAP理论中的C是指对一个数据多个备份的读写一致性。表面上看，这两者不是一回事，但实际上却是本质基本相同的事物：数据请求会等待多个相关数据操作全部完成才返回。对分布式系统来讲，这就是我们通常所说的分布式事务问题。</p>
<p>众所周知，分布式事务一般采用两阶段提交策略来实现，这是一个非常耗时的复杂过程，会严重影响系统效率，在实践中我们尽量避免使用它。在实践过程中，如果我们为了扩展数据容量将数据分布式存储，而事务的要求又完全不能降低，那么系统的可用性一定会大大降低。在现实中我们一般都采用对这些数据不分散存储的策略。</p>
<p>当然，我们也可以说，最常使用的关系型数据库因为这个原因，扩展性（分区可容忍性P）受到了限制，这是完全符合CAP理论的。但同时我们应该意识到，这对NoSQL数据库也是一样的。如果NoSQL数据库也要求严格的分布式事务功能，情况并不会比关系型数据库好多少。只是在NoSQL的设计中，我们往往会弱化，甚至去除事务的功能，该问题才表现得不那么明显而已。</p>
<p>因此，在扩展性问题上，如果要说关系型数据库是为了保证C、A而牺牲P，在尽量避免分布式事务这一点上来看，应该是正确的。也就是说：关系型数据库应该具有强大的事务功能，如果分区扩展，可用性就会降低。而NoSQL数据库干脆弱化，甚至去除了事务功能。因此，分区的可扩展性就大大增加了。</p>
<p>再来看看分布式环境中的关联场景。初看起来，关系型数据库中常用的多表关联操作与CAP理论就更加不沾边了。但仔细想想，也可以用它来解释数据库分区扩展对关联所带来的影响。对一个数据库来讲，采用了分区扩展策略来扩充容量，数据分散存储了，很显然多表关联的性能就会下降。因为我们必须在网络上进行大量的数据迁移操作，这与CAP理论中数据副本之间的同步操作，本质上也是相同的。</p>
<p>因此，如果要保证系统的高可用性，需要同时实现强大的多表关系操作的关系型数据库，在分区可扩展性上就遇到了极大的限制（即使是那些采用了各种优秀解决方案的MPP架构的关系型数据库，如TeraData，Netezza等，其水平可扩展性也是远远不如NoSQL数据库的）。而NoSQL数据库则干脆在设计上弱化，甚至去除了多表关联操作。那么，从这一点上来理解“NoSQL数据库是为了保证A与P，而牺牲C”的说法也是可以讲得通的。当然，我们应该理解，关联问题在很多情况下不是并行处理的优点所在，这在很大程度上与Amdahl定律相符合。</p>
<p>所以，从事务与关联的角度来看关系型数据库的分区可扩展性为什么受限的原因是最为清楚的。而NoSQL数据库也正是因为弱化，甚至去除了像事务与关联（全面地讲，其实还有索引等特性）等在分布式环境中会严重影响系统可用性的功能，才获得了更好的水平可扩展性。</p>
<p>那么，如果将事务与关联也纳入CAP理论中一致性C的范畴的话，问题就很清楚了：关于“关系型数据库为了保证一致性C与可用性A，而不得不牺牲分区可容忍性P”的说法便是正确的了。但关于“NoSQL选择了C与P，或者A与P”的说法则是错误的。所有的NoSQL数据库在设计策略的大方向上都是选择了A与P（虽然对同一数据多个副本的读写一致性问题的设计各有不同），从来没有完全选择C与P的情况存在。</p>
<p>结论</p>
<p>现在看来，如果理解CAP理论只是指多个数据副本之间读写一致性的问题，那么它对关系型数据库与NoSQL数据库来讲是完全一样的。它只是运行在分布式环境中的数据管理设施在设计读写一致性问题时需要遵循的一个原则而已，却并不是NoSQL数据库具有优秀的水平可扩展性的真正原因。而如果将CAP理论中的一致性C理解为读写一致性、事务与关联操作的综合，则可以认为关系型数据库选择了C与A，而NoSQL数据库则全都是选择了A与P，并没有选择C与P的情况存在。这才是用CAP理论来支持NoSQL数据库设计的正确认识。</p>
<p>其实，这种认识正好与被广泛认同的NoSQL的另一个理论基础相吻合，即与ACID对着干的BASE（基本可用性、软状态与最终一致性）。因为BASE的含义正好是指“NoSQL数据库设计可以通过牺牲一定的数据一致性和容错性来换取高性能的保持，甚至提高”，即NoSQL数据库都应该是牺牲C来换取P，而不是牺牲A。可用性A正好是所有NoSQL数据库都普遍追求的特性。（更多内容详见: <a href="http://www.cnw.com.cn/P/5523）" target="_blank" rel="external">http://www.cnw.com.cn/P/5523）</a><br>转自网界网：<a href="http://weekly.cnw.com.cn/weekly/htm2014/20140312_293558.shtml" target="_blank" rel="external">http://weekly.cnw.com.cn/weekly/htm2014/20140312_293558.shtml</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/thorem/">thorem</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/thorem-distribute/">thorem, distribute</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/01/cap-theorem/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/01/cap-theorem/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/10/maven-param/" title="maven param" itemprop="url">maven param</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-04-09T21:53:49.000Z" itemprop="datePublished"> 发表于 2015-04-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/04/10/maven-param/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/04/10/maven-param/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/27/mongodb/" title="mongodb" itemprop="url">mongodb</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="silveringsea" target="_blank" itemprop="author">silveringsea</a>
		
  <p class="article-time">
    <time datetime="2015-03-27T03:07:58.000Z" itemprop="datePublished"> 发表于 2015-03-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="u914D_u7F6E_u62A5_u9519"><a href="#u914D_u7F6E_u62A5_u9519" class="headerlink" title="配置报错"></a>配置报错</h4><p>debian8 jessi下的mongodb3安装：<a href="http://hut8.io/posts/mongodb-3-on-debian-jessie/" target="_blank" rel="external">http://hut8.io/posts/mongodb-3-on-debian-jessie/</a><br>Install using the repository for wheezy<br>sudo apt-key adv –keyserver ‘keyserver.ubuntu.com’ –recv ‘7F0CEB10’<br>echo ‘deb <a href="http://repo.mongodb.org/apt/debian" target="_blank" rel="external">http://repo.mongodb.org/apt/debian</a> wheezy/mongodb-org/3.0 main’ | sudo tee ‘/etc/apt/sources.list.d/mongodb-org-3.0.list’<br>sudo apt-get update<br>sudo apt-get install -y mongodb-org<br>Do not start MongoDB yet if you want to use WiredTiger!<br>Replace the configuration<br>The new YAML configuration format is way better than the old format, but the Debian wheezy package ships with the old format. So edit /etc/mongod.conf and replace it with equivalent YAML options. This is what I came up with. The engine: “wiredTiger” part is what prompted me to switch to the new configuration format.</p>
<p>storage:<br>  dbPath: “/var/lib/mongodb”<br>  engine: “wiredTiger”<br>  wiredTiger:<br>    collectionConfig:<br>      blockCompressor: snappy</p>
<p>systemLog:<br>  destination: file<br>  path: “/var/log/mongodb/mongodb.log”<br>  logAppend: true<br>  timeStampFormat: iso8601-utc</p>
<p>net:<br>  bindIp: “127.0.0.1”<br>  port: 27017<br>WiredTiger<br>Hopefully you’ve specified in the configuration file that you want to use the wiredTiger storage engine before MongoDB starts for the first time. I did not do this. This leaves the /var/lib/mongodb directory full of files compatible only with MMAPv1. The easiest ay to fix this is just to delete all the files in the data directory after stopping MongoDB:</p>
<p>Don’t do this if you have data loaded already<br>sudo systemctl stop mongod.service<br>sudo rm -rf /var/lib/mongodb/*<br>Then add the engine: “wiredTiger” option, as shown above. Restarting should work fine. If you choose to invoke MongoDB without the init script / systemctl (which is useful with debugging), make sure that you use:</p>
<p>sudo -u mongodb mongod [… options]<br>Otherwise, mongod will create necessary files owned by either root or yourself, depending on whether you used sudo or not, which will lead to tricky issues such as the log (where error messages go!) not being writable by the mongodb user.</p>
<p><a href="http://zhuanlan.zhihu.com/mysql/19967617" target="_blank" rel="external">知乎</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 写篇文章时，<span class="number">2.8</span>版本还没有出。据我的生产实践，Mongodb占据的磁盘空间比MySQL大得多，可以理解文档数据如Json这种格式，存在许多冗余数据，但空间占用大得不正常，甚至是传统数据库的三四倍，不太契合工程实践，应该有改善的余地。 查阅了一些资料，</span><br><span class="line"></span><br><span class="line">具体理下Mongodb的空间分配。<span class="number">1.</span> MongoDB每个库逻辑上包含许多集合（collection）,物理上存储为多个数据文件，数据文件的分配是预先分配的，预分配的方式可以减少碎片，程序申请磁盘空间的时候更高效，但MongoDB预分配的策略可能导致空间的浪费。默认的分配空间的策略是：随着数据库数据的增加，MongoDB会不断分配更多的数据文件。每个新数据文件的大小都是上一个已分配文件的两倍( <span class="number">64</span>M, <span class="number">128</span>M, <span class="number">256</span>M, <span class="number">512</span>M, <span class="number">1</span>G, <span class="number">2</span>G, <span class="number">2</span>G, <span class="number">2</span>G )，直到预分配文件大小的上限<span class="number">2</span>G。虽然<span class="number">2</span>G的阀值可以调整，但一般运维等时候往往也不会去调整，就这点来说，可能导致空间的浪费。对于磁盘的空间的分配效率，我报以怀疑的态度，如果本身有IO瓶颈，预分配一个<span class="number">2</span>G的文件，将可能导致服务出现严重性能问题。预分配文件，可以减少碎片，提高程序申请空间的效率，但有无必要一次分配初始化一个巨大的文件，这点值得商榷。 虽然预分配的机制，文档记载是可以关闭的，但一般使用NOSQL产品都是会使用默认配置，也建议使用默认的配置，因默认配置往往经历了长久的考验，没有那么多bug。<span class="number">2.</span> MongoDB的文档在数据文件中是连续存储的，这点不同于一些关系数据库的做法（它们会把长记录拆分为两部分，溢出的那部分单独存放在另一处），如果没有预留足够的空间，那么更新可能导致原有空间放不下新的文档。当更新迫使引擎在BSON存储中移动文档时，存储碎片可以导致意外的延迟。对此MongoDB官方的解释是如下，“如果有足够的空间，在MongoDB中更新文档时，数据会在原地更新。如果更新后的文档大小大于已经分配的空间，那么文档会在一个新位置被重写。MongoDB最终会重用原来的空间，但这可能需要时间，而且空间可能会过度分配。在MongoDB <span class="number">2.6</span>中，默认的空间分配策略将是powerOf2Sizes，这个选项从MongoDB <span class="number">2.2</span>开始就已经提供了。该设置会将MongoDB分配的空间大小向上取整为<span class="number">2</span>的幂（比如，<span class="number">2</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">8</span>、<span class="number">16</span>、<span class="number">32</span>、<span class="number">64</span>等等）。该设置会降低需要移动文档的几率，并使空间可以更高效地重用，结果是更少的空间过度分配和更可预测的性能。用户仍然可以使用精确匹配的分配策略，如果文档大小不增加，该策略更节省空间。”显然，这种策略又将导致空间的浪费，特别是对于导入只读类型的数据。<span class="number">3.</span> MongoDB不支持数据文件的压缩，也不能回收空间。它所使用的碎片整理的策略，可能是在一个新的地方重写，而不是对旧的碎片进行整理、合并。<span class="number">4.</span> 不校验数据页。页面校验对于数据库是非常重要的，有助于识别存储设备异常。就这点，MongoDB存储的数据是不安全的，也许哪天就起不来了。</span><br></pre></td></tr></table></figure></p>
<p><a href="http://zhuanlan.zhihu.com/mysql/19967630" target="_blank" rel="external">知乎</a><br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb写入数据是靠操作系统的缓存来实现的，我们需要清楚这中间发生了什么？对于更新操作，可能存在以下两种状态。pre-fsync post-update <span class="keyword">state</span>   对数据的变更已经写入journal日志，但日志并没有刷新（fsync)的磁盘上post-fsync post-update <span class="keyword">state</span> 对数据的变更已经刷新到日志文件，这个时候，如果宕机，可以利用journal日志进行灾难恢复。那么在pre-fsync post-update <span class="keyword">state</span>阶段，如果宕机了。很可能会丢失数据，因为连日志都没有刷新到磁盘。此时会出现这样一种情况，用户读取到了新的数据，然后宕机了，这个数据被丢失了。 用户读到了数据，但这个数据后来又不存在了，这种情况是否有问题呢？ 得看应用。mongodb提供了其他选项，写入操作可被<span class="built_in">block</span>，直到从库应答后（具体机制我不记得了，可能和MySQL的半同步类似的道理）。但主库上面的读取操作也许仍然可以读取到新的值（不必等从库应答）注意：由于mmap的机制，如果只是mongod进程挂了。那么不会丢失数据，因为操作系统没有挂，操作系统会继续写入完数据的。还有一点需要留意，对于数据库来说，比如MySQL在读取和写入页块的时候，会对页块进行校验，但mongodb不会，对于重要的数据来说，这是不能接受的。很可能因为硬件的故障导致数据异常而DBA不知道。</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/nosql/">nosql</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/nosql/">nosql</a><a href="/tags/tools/">tools</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/03/27/mongodb/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/03/27/mongodb/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/10/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/android/" title="android">android<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/ios/" title="ios">ios<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>20</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/nosql/" title="nosql">nosql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/osx/" title="osx">osx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/settings/" title="settings">settings<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/test/" title="test">test<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/thorem/" title="thorem">thorem<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/tools/" title="tools">tools<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/java/" title="java">java<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/tools/" title="tools">tools<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/test/" title="test">test<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/new-feature/" title="new feature">new feature<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nosql/" title="nosql">nosql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/development-tools/" title="development tools">development tools<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/settings/" title="settings">settings<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/websocket/" title="websocket">websocket<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/activemq/" title="activemq">activemq<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vim-tools/" title="vim, tools">vim, tools<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/zookeeper/" title="zookeeper">zookeeper<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/html5/" title="html5">html5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/tomcat/" title="tomcat">tomcat<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/apache/" title="apache">apache<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/netty/" title="netty">netty<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://iteye.com" target="_blank" title="iteye">iteye</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Rony running on silveringsea <br/>
			Help and be yourself</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1921609945" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="silveringsea">silveringsea</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"silveringsea"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>


<script src="/js/ua-parser.js"></script>
<script type="text/javascript">
$(function() {
  if (typeof DUOSHUO !== 'undefined')hookDUOSHUO_tp();
  else $('[src="http://static.duoshuo.com/embed.js"]')[0].onload=hookDUOSHUO_tp;
});
function hookDUOSHUO_tp(){
    var _D_post=DUOSHUO.templates.post
    DUOSHUO.templates.post=function (e,t){
        var rs=_D_post(e,t);
        var agent=e.post.agent;
        if(agent&&/^Mozilla/.test(agent))rs=rs.replace(/<\/div><p>/,show_ua(agent)+'</div><p>');
        return rs;
    }
}
function show_ua(string){
    //console.log(string)
    $.ua.set(string);
    var sua=$.ua;
    if(sua.os.version=='x86_64')sua.os.version='x64';
    return '<span class="this_ua platform '+sua.os.name+'">'+sua.os.name+' '+sua.os.version+'</span><span class="this_ua browser '+sua.browser.name+'">'+sua.browser.name+'|'+sua.browser.version+'</span>';
}
</script>

<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
